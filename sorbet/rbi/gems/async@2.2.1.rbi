# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async` gem.
# Please instead update this file by running `bin/tapioca gem async`.

# source://async//lib/async/version.rb#6
module Async; end

# A list of children tasks.
#
# source://async//lib/async/node.rb#110
class Async::Children < ::Async::List
  # @return [Children] a new instance of Children
  #
  # source://async//lib/async/node.rb#111
  def initialize; end

  # source://async//lib/async/node.rb#130
  def delete(item); end

  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#138
  def finished?; end

  # source://async//lib/async/node.rb#122
  def insert(item); end

  # Does this node have (direct) transient children?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#118
  def transients?; end
end

# A convenient wrapper around the internal monotonic clock.
#
# source://async//lib/async/clock.rb#9
class Async::Clock
  # Create a new clock with the initial total time.
  #
  # @return [Clock] a new instance of Clock
  #
  # source://async//lib/async/clock.rb#34
  def initialize(total = T.unsafe(nil)); end

  # Start measuring a duration.
  #
  # source://async//lib/async/clock.rb#40
  def start!; end

  # Stop measuring a duration and append the duration to the current total.
  #
  # source://async//lib/async/clock.rb#45
  def stop!; end

  # The total elapsed time including any current duration.
  #
  # source://async//lib/async/clock.rb#55
  def total; end

  class << self
    # Measure the execution of a block of code.
    #
    # source://async//lib/async/clock.rb#18
    def measure; end

    # Get the current elapsed monotonic time.
    #
    # source://async//lib/async/clock.rb#11
    def now; end

    # Start measuring elapsed time from now.
    #
    # source://async//lib/async/clock.rb#28
    def start; end
  end
end

# A synchronization primitive, which allows fibers to wait until a particular condition is (edge) triggered.
#
# source://async//lib/async/condition.rb#13
class Async::Condition
  # @return [Condition] a new instance of Condition
  #
  # source://async//lib/async/condition.rb#14
  def initialize; end

  # Is any fiber waiting on this notification?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#47
  def empty?; end

  # Signal to a given task that it should resume operations.
  #
  # source://async//lib/async/condition.rb#53
  def signal(value = T.unsafe(nil)); end

  # Queue up the current fiber and wait on yielding the task.
  #
  # source://async//lib/async/condition.rb#36
  def wait; end
end

# source://async//lib/async/condition.rb#18
class Async::Condition::Queue < ::Struct
  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#23
  def alive?; end

  # Returns the value of attribute fiber
  #
  # @return [Object] the current value of fiber
  def fiber; end

  # Sets the attribute fiber
  #
  # @param value [Object] the value to set the attribute fiber to.
  # @return [Object] the newly set value
  def fiber=(_); end

  # source://async//lib/async/condition.rb#27
  def nullify; end

  # source://async//lib/async/condition.rb#19
  def transfer(*arguments); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# A double linked list used for managing tasks.
#
# source://async//lib/async/node.rb#10
class Async::List
  # @return [List] a new instance of List
  #
  # source://async//lib/async/node.rb#11
  def initialize; end

  # source://async//lib/async/node.rb#47
  def delete(item); end

  # source://async//lib/async/node.rb#68
  def each(&block); end

  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#98
  def empty?; end

  # source://async//lib/async/node.rb#90
  def first; end

  # Returns the value of attribute head.
  #
  # source://async//lib/async/node.rb#20
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  #
  # source://async//lib/async/node.rb#20
  def head=(_arg0); end

  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#82
  def include?(needle); end

  # Inserts an item at the end of the list.
  #
  # source://async//lib/async/node.rb#24
  def insert(item); end

  # source://async//lib/async/node.rb#94
  def last; end

  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#102
  def nil?; end

  # Returns the value of attribute size.
  #
  # source://async//lib/async/node.rb#18
  def size; end

  # Returns the value of attribute tail.
  #
  # source://async//lib/async/node.rb#21
  def tail; end

  # Sets the attribute tail
  #
  # @param value the value to set the attribute tail to.
  #
  # source://async//lib/async/node.rb#21
  def tail=(_arg0); end
end

# A node in a tree, used for implementing the task hierarchy.
#
# source://async//lib/async/node.rb#144
class Async::Node
  # Create a new node in the tree.
  #
  # @return [Node] a new instance of Node
  #
  # source://async//lib/async/node.rb#147
  def initialize(parent = T.unsafe(nil), annotation: T.unsafe(nil), transient: T.unsafe(nil)); end

  # source://async//lib/async/node.rb#194
  def annotate(annotation); end

  # A useful identifier for the current node.
  #
  # source://async//lib/async/node.rb#182
  def annotation; end

  # source://async//lib/async/node.rb#217
  def backtrace(*arguments); end

  # Returns the value of attribute children.
  #
  # source://async//lib/async/node.rb#179
  def children; end

  # Whether there are children?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#185
  def children?; end

  # If the node has a parent, and is {finished?}, then remove this node from
  # the parent.
  #
  # source://async//lib/async/node.rb#269
  def consume; end

  # source://async//lib/async/node.rb#205
  def description; end

  # Whether the node can be consumed safely. By default, checks if the
  # children set is empty.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#263
  def finished?; end

  # @private
  #
  # source://async//lib/async/node.rb#170
  def head; end

  # @private
  #
  # source://async//lib/async/node.rb#170
  def head=(_arg0); end

  # source://async//lib/async/node.rb#221
  def inspect; end

  # Returns the value of attribute parent.
  #
  # source://async//lib/async/node.rb#176
  def parent; end

  # Change the parent of this node.
  #
  # source://async//lib/async/node.rb#230
  def parent=(parent); end

  # source://async//lib/async/node.rb#332
  def print_hierarchy(out = T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # source://async//lib/async/node.rb#165
  def root; end

  # Attempt to stop the current node immediately, including all non-transient children.
  # Invokes {#stop_children} to stop all children.
  #
  # source://async//lib/async/node.rb#316
  def stop(later = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#328
  def stopped?; end

  # @private
  #
  # source://async//lib/async/node.rb#173
  def tail; end

  # @private
  #
  # source://async//lib/async/node.rb#173
  def tail=(_arg0); end

  # Immediately terminate all children tasks, including transient tasks.
  # Internally invokes `stop(false)` on all children.
  #
  # source://async//lib/async/node.rb#303
  def terminate; end

  # source://async//lib/async/node.rb#221
  def to_s; end

  # Is this node transient?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#190
  def transient?; end

  # Traverse the tree.
  #
  # @yield [_self, level]
  # @yieldparam _self [Async::Node] the object that the method was called on
  #
  # source://async//lib/async/node.rb#293
  def traverse(level = T.unsafe(nil), &block); end

  protected

  # source://async//lib/async/node.rb#249
  def add_child(child); end

  # source://async//lib/async/node.rb#255
  def delete_child(child); end

  # source://async//lib/async/node.rb#245
  def set_parent(parent); end

  private

  # source://async//lib/async/node.rb#344
  def print_backtrace(out, indent, node); end

  # Attempt to stop all non-transient children.
  #
  # source://async//lib/async/node.rb#322
  def stop_children(later = T.unsafe(nil)); end
end

# A wrapper around the the scheduler which binds it to the current thread automatically.
#
# source://async//lib/async/reactor.rb#13
class Async::Reactor < ::Async::Scheduler
  # @return [Reactor] a new instance of Reactor
  #
  # source://async//lib/async/reactor.rb#18
  def initialize(*_arg0, **_arg1, &_arg2); end

  class << self
    # @deprecated Replaced by {Kernel::Async}.
    #
    # source://async//lib/async/reactor.rb#14
    def run(*_arg0, **_arg1, &_arg2); end
  end
end

# Handles scheduling of fibers. Implements the fiber scheduler interface.
#
# source://async//lib/async/scheduler.rb#21
class Async::Scheduler < ::Async::Node
  # @return [Scheduler] a new instance of Scheduler
  #
  # source://async//lib/async/scheduler.rb#26
  def initialize(parent = T.unsafe(nil), selector: T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#138
  def address_resolve(hostname); end

  # Start an asynchronous task within the specified reactor. The task will be
  # executed until the first blocking call, at which point it will yield and
  # and this method will return.
  #
  # This is the main entry point for scheduling asynchronus tasks.
  #
  # @deprecated With no replacement.
  #
  # source://async//lib/async/scheduler.rb#246
  def async(*arguments, **options, &block); end

  # Invoked when a fiber tries to perform a blocking operation which cannot continue. A corresponding call {unblock} must be performed to allow this fiber to continue.
  #
  # source://async//lib/async/scheduler.rb#97
  def block(blocker, timeout); end

  # source://async//lib/async/scheduler.rb#38
  def close; end

  # @return [Boolean]
  #
  # source://async//lib/async/scheduler.rb#57
  def closed?; end

  # source://async//lib/async/scheduler.rb#262
  def fiber(*_arg0, **_arg1, &_arg2); end

  # Interrupt the event loop and cause it to exit.
  #
  # source://async//lib/async/scheduler.rb#66
  def interrupt; end

  # source://async//lib/async/scheduler.rb#164
  def io_read(io, buffer, length, offset = T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#143
  def io_wait(io, events, timeout = T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#168
  def io_write(io, buffer, length, offset = T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#129
  def kernel_sleep(duration = T.unsafe(nil)); end

  # Wait for the specified process ID to exit.
  #
  # source://async//lib/async/scheduler.rb#178
  def process_wait(pid, flags); end

  # Schedule a fiber (or equivalent object) to be resumed on the next loop through the reactor.
  #
  # source://async//lib/async/scheduler.rb#83
  def push(fiber); end

  # source://async//lib/async/scheduler.rb#87
  def raise(*arguments); end

  # source://async//lib/async/scheduler.rb#91
  def resume(fiber, *arguments); end

  # Run the reactor until all tasks are finished. Proxies arguments to {#async} immediately before entering the loop, if a block is provided.
  #
  # source://async//lib/async/scheduler.rb#219
  def run(*_arg0, **_arg1, &_arg2); end

  # Run one iteration of the event loop.
  #
  # source://async//lib/async/scheduler.rb#185
  def run_once(timeout = T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#282
  def timeout_after(duration, exception, message, &block); end

  # source://async//lib/async/scheduler.rb#61
  def to_s; end

  # Transfer from the calling fiber to the event loop.
  #
  # source://async//lib/async/scheduler.rb#72
  def transfer; end

  # source://async//lib/async/scheduler.rb#120
  def unblock(blocker, fiber); end

  # Invoke the block, but after the specified timeout, raise {TimeoutError} in any currenly blocking operation. If the block runs to completion before the timeout occurs or there are no non-blocking operations after the timeout expires, the code will complete without any exception.
  #
  # source://async//lib/async/scheduler.rb#268
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield the current fiber and resume it on the next iteration of the event loop.
  #
  # source://async//lib/async/scheduler.rb#77
  def yield; end

  class << self
    # Whether the fiber scheduler is supported.
    #
    # @return [Boolean]
    #
    # source://async//lib/async/scheduler.rb#22
    def supported?; end
  end
end

# Raised when a task is explicitly stopped.
#
# source://async//lib/async/task.rb#16
class Async::Stop < ::Exception; end

# source://async//lib/async/task.rb#17
class Async::Stop::Later
  # @return [Later] a new instance of Later
  #
  # source://async//lib/async/task.rb#18
  def initialize(task); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#22
  def alive?; end

  # source://async//lib/async/task.rb#26
  def transfer; end
end

# Encapsulates the state of a running task and it's result.
#
# source://async//lib/async/task.rb#43
class Async::Task < ::Async::Node
  # Create a new task.
  #
  # @return [Task] a new instance of Task
  #
  # source://async//lib/async/task.rb#51
  def initialize(parent = T.unsafe(nil), finished: T.unsafe(nil), **options, &block); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#94
  def alive?; end

  # source://async//lib/async/task.rb#114
  def async(*arguments, **options, &block); end

  # source://async//lib/async/task.rb#67
  def backtrace(*arguments); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#208
  def complete?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#184
  def current?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#200
  def failed?; end

  # @attr fiber [Fiber] The fiber which is being used for the execution of this task.
  #
  # source://async//lib/async/task.rb#92
  def fiber; end

  # Whether we can remove this node from the reactor graph.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#196
  def finished?; end

  # source://async//lib/async/task.rb#62
  def reactor; end

  # Access the result of the task without waiting. May be nil if the task is not completed.
  #
  # source://async//lib/async/task.rb#142
  def result; end

  # Begin the execution of the task.
  #
  # source://async//lib/async/task.rb#102
  def run(*arguments); end

  # Check if the task is running.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#190
  def running?; end

  # @deprecated Prefer {Kernel#sleep} except when compatibility with `stable-v1` is required.
  #
  # source://async//lib/async/task.rb#77
  def sleep(duration = T.unsafe(nil)); end

  # @attr status [Symbol] The status of the execution of the fiber, one of `:initialized`, `:running`, `:complete`, `:stopped` or `:failed`.
  #
  # source://async//lib/async/task.rb#99
  def status; end

  # Stop the task and all of its children.
  #
  # source://async//lib/async/task.rb#145
  def stop(later = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#204
  def stopped?; end

  # source://async//lib/async/task.rb#72
  def to_s; end

  # Retrieve the current result of the task. Will cause the caller to wait until result is available.
  # @raises[RuntimeError] If the task's fiber is the current fiber.
  #
  # source://async//lib/async/task.rb#125
  def wait; end

  # Execute the given block of code, raising the specified exception if it exceeds the given duration during a non-blocking operation.
  #
  # source://async//lib/async/task.rb#82
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield back to the reactor and allow other fibers to execute.
  #
  # source://async//lib/async/task.rb#87
  def yield; end

  private

  # This is a very tricky aspect of tasks to get right. I've modelled it after `Thread` but it's slightly different in that the exception can propagate back up through the reactor. If the user writes code which raises an exception, that exception should always be visible, i.e. cause a failure. If it's not visible, such code fails silently and can be very difficult to debug.
  #
  # source://async//lib/async/task.rb#215
  def fail!(exception = T.unsafe(nil), propagate = T.unsafe(nil)); end

  # Finish the current task, and all bound bound IO objects.
  #
  # source://async//lib/async/task.rb#262
  def finish!; end

  # source://async//lib/async/task.rb#238
  def schedule(&block); end

  # Set the current fiber's `:async_task` to this task.
  #
  # source://async//lib/async/task.rb#276
  def set!; end

  # source://async//lib/async/task.rb#231
  def stop!; end

  class << self
    # Lookup the {Task} for the current fiber. Raise `RuntimeError` if none is available.
    # @raises[RuntimeError] If task was not {set!} for the current fiber.
    #
    # source://async//lib/async/task.rb#174
    def current; end

    # Check if there is a task defined for the current fiber.
    #
    # @return [Boolean]
    #
    # source://async//lib/async/task.rb#180
    def current?; end

    # @deprecated With no replacement.
    #
    # source://async//lib/async/task.rb#44
    def yield; end
  end
end

# Raised if a timeout occurs on a specific Fiber. Handled gracefully by `Task`.
#
# source://async//lib/async/task.rb#34
class Async::TimeoutError < ::StandardError
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://async//lib/async/task.rb#35
  def initialize(message = T.unsafe(nil)); end
end

# source://async//lib/async/version.rb#7
Async::VERSION = T.let(T.unsafe(nil), String)

# Extensions to all Ruby objects.
#
# source://async//lib/kernel/async.rb#8
module Kernel
  # Run the given block of code in a task, asynchronously, creating a reactor if necessary.
  #
  # The preferred method to invoke asynchronous behavior at the top level.
  #
  # - When invoked within an existing reactor task, it will run the given block
  # asynchronously. Will return the task once it has been scheduled.
  # - When invoked at the top level, will create and run a reactor, and invoke
  # the block as an asynchronous task. Will block until the reactor finishes
  # running.
  #
  # source://async//lib/kernel/async.rb#24
  def Async(*_arg0, **_arg1, &_arg2); end

  # Run the given block of code synchronously, but within a reactor if not already in one.
  #
  # source://async//lib/kernel/sync.rb#18
  def Sync(&block); end
end
